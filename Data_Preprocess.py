# -*- coding: utf-8 -*-
"""rnn_july 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-meBIhprpndiVKQkakkjMRNwbIcIkIaS
"""

import pandas as pd
from pandas import to_numeric
import numpy as np
from keras import models
from keras import layers
from keras.layers import  LSTM, Dense, Dropout, SimpleRNN
from keras.models import Sequential
from keras.utils import to_categorical
from keras.layers import Dropout
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from matplotlib import pyplot as plt
import keras.utils as ku 
from keras.preprocessing.sequence import pad_sequences
from google.colab import files
from numpy import save
from numpy import load


# Global Variables
a=4
g=9
k=7
parsed_cycle_file = "parsed_cycles_data.csv"
parsed_decision_file = "parsed_routing_decision_data.csv"
time_step = 10
no_of_features = 7  # only considering the port occupancies


# load data
def load_data(filename, sep):
  dataset = pd.read_csv(filename, sep=sep, delim_whitespace=False)
  return dataset

cycle_dataset = load_data(parsed_cycle_file , ",")
# cycle_dataset = cycle_dataset.loc[:no_of_rows]
# print(cycle_dataset.shape)
# cycle_dataset.head(5)

routing_decision_dataset = load_data(parsed_decision_file, ",")
#routing_decision_dataset = routing_decision_dataset.loc[:no_of_rows]
# print(routing_decision_dataset.shape)
# routing_decision_dataset.head()



"""# Data Preprocess """

# define list for sequence and labels
list_of_vector_sequences = []
list_of_labels = []


# prepad sequence if sequence is less than the specified length
def prepad_sequences(temp_cycle_dataset, range_time):

  lower_bound = range_time[1]
  temp_history = temp_cycle_dataset.loc[temp_cycle_dataset['time'] <= range_time[0]]
  temp_history = temp_history.drop(columns=['router_id','time'] )

  # converting temp_history to numpy array
  temp_history_list = temp_history.to_numpy()
  past_history_list = []
  for j in range(1, abs(lower_bound)):
    list_zeroes = [0] * (no_of_features )
    past_history_list.append(list_zeroes)

  # converting to numpy array
  past_history_list = np.array(past_history_list)
  """
  print("temp history shape")
  print(temp_history_list.shape)

  print("past_history_list shape")
  print(past_history_list.shape)
  """
  if past_history_list.shape[0] > 0:
    # concatenating 2 numpy arrays
    past_history = np.concatenate([past_history_list, temp_history_list])
  else:
    past_history = temp_history_list.copy()
  past_history.astype(np.int)
  return past_history



def get_past_history(temp_cycle_dataset, range_time):
  # all the past sequences of this particular time step
  temp_history = temp_cycle_dataset.loc[temp_cycle_dataset['time'] <= range_time[0]]
  temp_history = temp_history.loc[temp_history["time"] > range_time[1]]
  temp_history = temp_history.drop(columns = ['router_id','time'])
  past_history = temp_history.to_numpy()
  past_history.astype(np.int)
  return past_history



def process_dataset_for_this_router(temp_cycle_dataset, temp_routing_decision):

  for i in range(temp_routing_decision.shape[0]): 
    """
    print("router event info")  # printing a particular event info
    print(temp_routing_decision.iloc[i])
    """
    # router event time
    router_event_time = temp_routing_decision.iloc[i]["time"]

    # Finding routing labels
    router_routing_decision = temp_routing_decision.iloc[i]["routing"]

    # range of time step
    range_time = [router_event_time,router_event_time - time_step]
    """
    print("Range Time")
    print(range_time)
    """
    lower_bound = range_time[1]
    if lower_bound < 0:
      # need to prepad if lower bound of the range is negative
      past_history = prepad_sequences(temp_cycle_dataset, range_time)
    else :
      # get past history
      past_history = get_past_history(temp_cycle_dataset, range_time)

    # append to list of feature-vector-sequences
    list_of_vector_sequences.append(past_history)

    # append to list of labels
    list_of_labels.append(router_routing_decision)

# reset list_of_vector_sequences 
list_of_vector_sequences = []
list_of_labels = []


def dataset_preparation():
  no_of_routers = a * g
  print(no_of_routers)
  for router in range(no_of_routers):
    temp_cycle_dataset = cycle_dataset.loc[cycle_dataset['router_id']==router]
    #print(temp_cycle_dataset)
    temp_routing_decision = routing_decision_dataset.loc[routing_decision_dataset['src'] == router]
    #print(temp_routing_decision)
    process_dataset_for_this_router(temp_cycle_dataset, temp_routing_decision)


dataset_preparation()


"""**Wait............................................**"""

list_of_vector_sequences_copied = list_of_vector_sequences.copy()
list_of_vector_sequences_copied = np.array(list_of_vector_sequences_copied)
list_of_vector_sequences_copied.shape, list_of_vector_sequences_copied.dtype
list_of_vector_sequences_copied = list_of_vector_sequences_copied.reshape(list_of_vector_sequences_copied.shape[0], list_of_vector_sequences_copied.shape[1], list_of_vector_sequences_copied.shape[2])

print(list_of_vector_sequences_copied[:10])

# save to npy file
np.save('time_step_data.npy', list_of_vector_sequences_copied)

# load array
loaded_data = np.load('time_step_data.npy')

# download data
files.download('time_step_data.npy')


shape_1 = loaded_data.shape[0]
shape_2 = loaded_data.shape[1]
shape_3 = loaded_data.shape[2]
loaded_data = loaded_data.reshape(shape_1, shape_2, shape_3 )

list_of_labels_copied = list_of_labels
list_of_labels_copied = np.array(list_of_labels_copied)
list_of_labels_copied.astype(np.int)

print("list_of_labels")
print(len(list_of_labels_copied))

# save to npy file
np.save('labels_data.npy', list_of_labels_copied)

# load array
loaded_label_data = load('labels_data.npy')

# download data
files.download('labels_data.npy')

